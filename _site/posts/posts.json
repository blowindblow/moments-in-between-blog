[
  {
    "path": "posts/2022-02-06-tidytuesday-bee-colonies/",
    "title": "Tidytuesday: Bee colonies",
    "description": "<i>The Scientist said the bumblebee couldn't fly, <br/>\nshe lacked the wingbeats per minute or the necessary size<\/i>",
    "author": [
      {
        "name": "Jolene",
        "url": {}
      }
    ],
    "date": "2022-02-06",
    "categories": [
      "tidytuesday"
    ],
    "contents": "\r\n\r\nContents\r\nThe final product\r\nSome ggplot takeaways\r\nRemove legend marking inside the legend key\r\nAdjust vertical spacing between legend items\r\nPlacement of legends\r\nReduce vertical spacing between facets\r\nAdditional text descriptions\r\n\r\n\r\nI don‚Äôt know much about bees but I do know a lovely poem ‚ÄúThe Scientist and The Bumblebee‚Äù by Harry Baker. It is about how scientists once proved that bumblebees should not be able to fly but they obviously can fly.\r\n\r\nSo don‚Äôt ever let someone tell you what you can‚Äôt do, because just because it‚Äôs proven,  doesn‚Äôt mean it‚Äôs true\r\n\r\nHere‚Äôs a stanza that is vaguely relevant:\r\n\r\nThey‚Äôd rather follow their charts  than follow their hearts.  If they saw a bee leave  they‚Äôd still follow their graphs.  They preferred facts and figures  to beeswax and vigour,  but she begged to differ  as she flew past and laughed.\r\n\r\nThis tidytuesday presented an opportunity to use {geofacet} üì¶. I have seen it often but this is my first time using it. I decided to visualise the average percentage of lost bee colonies and the top stressors in each quarter for each state.\r\nSince I wanted the abbreviated name of the state (e.g.¬†AZ instead of Arizona), I used inner_join() to combine the the cleaned data set with the us_state_grid1 data which is part of {geofacet} üì¶.\r\n\r\n\r\nShow code\r\n\r\n# Load libraries and data -------------------------------------------------\r\nlibrary(tidyverse)\r\nlibrary(geofacet)\r\nlibrary(MetBrewer)\r\nlibrary(showtext)\r\n\r\ncolony <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-01-11/colony.csv')\r\nstressor <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-01-11/stressor.csv')\r\n\r\n# create grid that filters out missing states data\r\nmy_grid = us_state_grid1 %>% filter(name %in% colony$state)\r\n\r\n# Cleaning data -----------------------------------------------------------\r\nc <- colony %>% \r\n  filter(months != '2019') %>% \r\n  filter(!is.na(colony_lost_pct)) %>% \r\n  group_by(months, state) %>% \r\n  summarise(colony_lost_pct = mean(colony_lost_pct/100)) %>% \r\n  mutate(months = factor(months, labels = c('Q1','Q2','Q3','Q4'),\r\n         levels = c('January-March','April-June','July-September','October-December'))) %>%\r\n  inner_join(my_grid[3:4], by = c('state' = 'name')) \r\n  \r\ns <- stressor %>% \r\n  filter(months != '2019') %>% \r\n  mutate(stressor = ifelse(stressor=='Disesases','Diseases',stressor)) %>% \r\n  group_by(months, state, stressor) %>% \r\n  summarise(stressor_avg = mean(stress_pct/100, na.rm = TRUE)) %>% \r\n  mutate(months = factor(months, labels = c('Q1','Q2','Q3','Q4'),\r\n                         levels = c('January-March','April-June','July-September','October-December'))) %>%\r\n  inner_join(my_grid[3:4], by = c('state' = 'name')) \r\n\r\n\r\n\r\nI found that {dplyr} has join functions that work just like SQL joins. I love how intuitive SQL joins are.\r\nNext, I identified the top 3 stressors for each quarter and merged the datasets for plotting.\r\n\r\n\r\nShow code\r\n\r\n# identify on avg, the top 3 stressors for each quarter\r\ns_top3 <- s %>% \r\n  group_by(months, state) %>% \r\n  slice_max(stressor_avg, n = 3) %>% \r\n  arrange(-stressor_avg, .by_group = TRUE) %>% \r\n  mutate(rank = seq(1,3))\r\ns_top3$stressor <- factor(s_top3$stressor, levels = c('Varroa mites', 'Pesticides', 'Diseases',\r\n                                                       'Other pests/parasites', 'Other', 'Unknown'))\r\n\r\n# merge datasets for plotting\r\nc_s <- merge(s_top3, c, by = c('months','state','code'), all = T)\r\nc_s$stressor <-  factor(c_s$stressor, levels = c('Varroa mites', 'Pesticides', 'Diseases',\r\n                                                 'Other pests/parasites', 'Other', 'Unknown'))\r\n\r\n\r\n\r\nI placed the average percentage of bee colonies lost on the negative y axis since lost is negative and it seemed more intuitive. On the positive y axis, I illustrated the top 3 stressors for each quarter. It was difficult to do so without making the graph too cluttered. Ultimately, I used dodged geom_point and a single geom_segment. Although geom_point makes it a bit tougher to read the value of the exact point on the y axis, I figured that information was not of priority. The fill colour of the points that identify the stressors is more important. I wanted to keep the top stressor layered above the second and third stressors thus I separated them into three different geoms. To keep the graph neat, I opted for a single geom_segment. I really like the overall visual of the graph.\r\n\r\n\r\nShow code\r\n\r\npalette <- (c('#FFC857','#E9724C','#C5283D','#481D24','#255F85','#B1EDE8'))\r\n\r\nplot<-ggplot(c_s, aes(months, -colony_lost_pct)) +\r\n  geom_col(aes(fill = stressor),color = '#1b2b34', size = 0.2, width = 0.8) +\r\n  # split up each rank to ensure that the higher rank is layered above the lower rank (i.e. rank 1 above rank 2 & 3)\r\n  geom_segment(data = s_top3, aes(x = months, xend = months,y = 0, yend = stressor_avg), \r\n               position = position_dodge(0.1), size = 0.2)+\r\n  geom_point(data = s_top3 %>% filter(rank == 3), aes(x = months, y = stressor_avg, fill = stressor),\r\n             shape = 21, size = 1.2, stroke = 0.2, colour = \"#1b2b34\", show.legend = FALSE,\r\n             position = position_nudge(x = 0.18)) +\r\n  geom_point(data = s_top3 %>% filter(rank == 2), aes(x = months, y = stressor_avg, fill = stressor),\r\n             shape = 21, size = 1.2, stroke = 0.2, colour = \"#1b2b34\", show.legend = FALSE,\r\n             position = position_nudge(x = -0.18)) +\r\n  geom_point(data = s_top3 %>% filter(rank == 1), aes(x = months, y = stressor_avg, fill = stressor),\r\n             shape = 21, size = 1.2, stroke = 0.2, colour = \"#1b2b34\", show.legend = FALSE) +\r\n  \r\n  # scales and facet\r\n  scale_fill_manual(values = palette, drop = FALSE) +  # remove legend marking inside legend key! \r\n  guides(fill = guide_legend(byrow = TRUE)) +  # enables adjustment of spacing between legend items\r\n  scale_y_continuous(labels = scales::percent) +\r\n  facet_geo(facets = vars(code), grid = my_grid) +\r\n\r\n  # theme\r\n  coord_cartesian(clip = 'off') +\r\n  theme_minimal() +\r\n  theme(text=element_text(family='Raleway', size = rel(5)), \r\n        # facets\r\n        panel.spacing.y = unit(-0.5, \"lines\"),  # reduce vertical spacing between facets \r\n        axis.ticks.x = element_blank(),\r\n        panel.grid.major.y = element_line(size = .25, color = \"#ececec\"),\r\n        panel.grid.minor.y = element_blank(),\r\n        panel.grid.major.x = element_blank(),\r\n        axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),\r\n        strip.text = element_text(size = rel(4), margin = margin(t=10,r = 0, b = 2, l = 0)),\r\n        \r\n        # title, subtitle, description\r\n        plot.title = element_text(hjust = 0.5, size = rel(7), face = 'bold'),\r\n        plot.subtitle = element_text(hjust = 0.5, size = rel(5), color = '#1b2b34'),\r\n        plot.tag.position = c(0.04, 0.86),\r\n        plot.tag = element_text(size = rel(3.8), color  = '#1b2b34', hjust = 0, lineheight = 0.3),\r\n  \r\n        # legend\r\n        plot.margin=margin(c(0.5,1.5,0.5,0.5), unit=\"cm\"),  # extends right margin so that legend will not be cut off\r\n        legend.position = c(0.95, 0.3),\r\n        legend.text = element_text(size = rel(4.5), margin = margin(l = -8, unit = 'pt')),\r\n        legend.spacing.y = unit(0.4, 'lines'),  # only works if byrow = TRUE for guide_legend\r\n        legend.key.size = unit(0.7, 'lines')  # size of the square legend keys\r\n        ) + \r\n  \r\n  labs(x = NULL, y = '',\r\n       fill = 'Stressors',\r\n       title = 'Average percentage of bee colonies lost and the top three stressors in each quarter',\r\n       subtitle = 'From 2015Q1 to 2021Q2',\r\n       tag = 'The coloured circles illustrate the average top 3 stressors and the average \\npercentage of colonies affected by those stressors during the quarter.\\n\\nThe bars represent the average percentage of bee colonies lost\\nand their colours correspond to the top stressor in that quarter.'\r\n       ) \r\n\r\nggsave(\"bee_colonies.png\", plot, device = ragg::agg_png, width = 20, height = 15, units = \"cm\", res = 300)\r\n\r\n\r\n\r\nThe final product\r\n\r\n\r\n\r\nSome ggplot takeaways\r\nRemove legend marking inside the legend key\r\n\r\n\r\nscale_fill_manual(values = palette, drop = FALSE) \r\n\r\n\r\n\r\nAdjust vertical spacing between legend items\r\n\r\n\r\nguides(fill = guide_legend(byrow = TRUE)) +  # enables adjustment of spacing between legend items\r\ntheme(legend.spacing.y = unit(0.4, 'lines'))  # only works if byrow = TRUE for guide_legend\r\n\r\n\r\n\r\nPlacement of legends\r\nIn this graph, I wanted the legend inside the plot but near the edge. To do so, I specified the legend.position. Hence, Unfortunately, this causes the legend to be cut off. To mitigate that, I extended the right margin of the plot.\r\n\r\n\r\ntheme(plot.margin=margin(c(0.5,1.5,0.5,0.5), unit=\"cm\"), \r\n      legend.position = c(0.95, 0.3))\r\n\r\n\r\n\r\nReduce vertical spacing between facets\r\nSince there are a lot of facets, space was a huge constraint.\r\n\r\n\r\ntheme(panel.spacing.y = unit(-0.5, \"lines\")) \r\n\r\n\r\n\r\nAdditional text descriptions\r\nI wanted to have some text explaining how to read the graph but I already have a subtitle. I found that tag can be used to add text anywhere in the plot.\r\n\r\n\r\ntheme(plot.tag.position = c(0.04, 0.86),\r\n      plot.tag = element_text(size = rel(3.8), color = '#1b2b34', hjust = 0, lineheight = 0.3)) +\r\nlabs(tag = 'The coloured circles illustrate ...')\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-02-06T16:57:03+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-04-three-way-contingency-table/",
    "title": "Three-way contingency table",
    "description": "Testing mutual (and partial) independence of variables in a three-way contingency table",
    "author": [
      {
        "name": "Jolene",
        "url": {}
      }
    ],
    "date": "2022-02-04",
    "categories": [],
    "contents": "\r\nThis was one of my many attempts to analyse multiple categorical variables. The biostatistician whom I consulted suggested the use of a three-way contingency table as detailed in Chapter 4 (Multidimensional Tables) of the book ‚ÄúThe Analysis of Contingency Tables‚Äù (Everitt 1992). I spent some time writing a function for the proposed function. Someone has probably already written a function for this but I figured it would be good practice to write the function from scratch. It forces me to read the text in detail and fully understand the hypothesis testing. It was my first time using arrays in R. Before this, I never really had the need to explore beyond two dimensional dataframes.\r\n\r\n\r\nthree_way_xtab <- function(array, partial = 0){  \r\n  # if partial independence is of interest, set partial = 1\r\n  \r\n  # two variable marginals\r\n  n_ij <- apply(array, c(1, 2), sum)\r\n  n_ik <- apply(array, c(1, 3), sum)\r\n  n_jk <- apply(array, c(2, 3), sum)\r\n  \r\n  \r\n  # single variable marginals\r\n  n_i <- apply(array, 1, sum)\r\n  n_j <- apply(array, 2, sum)\r\n  n_k <- apply(array, 3, sum)\r\n  N <- sum(array)\r\n  \r\n  \r\n  # creating an empty array based on original data array\r\n  E <- array(0,\r\n             dim = dim(array),\r\n             dimnames = dimnames(array))\r\n  Ei <- E\r\n  Ej <- E\r\n  Ek <- E\r\n  \r\n  # loop to compute expected values\r\n  for (i in 1:nrow(array)) {\r\n    for (j in 1:ncol(array)) {\r\n      for (k in 1:nrow(aperm(array))) {\r\n        E[i, j, k] <- n_i[i] * n_j[j] * n_k[k] / N ^ 2\r\n      }\r\n    }\r\n  }\r\n  df = prod(dim(array)) - sum(dim(array)) + 2\r\n  chisq <- sum(((array - E) ^ 2) / E)  # test of mutual independence\r\n  pval  <- pchisq(chisq, df, lower.tail = FALSE)\r\n  \r\n  output <- list(\r\n      test   = \"3 variable contingency table\",\r\n      chisq  = chisq,\r\n      pvalue = pval,\r\n      df     = df,  # degrees of freedom\r\n      E      = E  # expected values under hypothesis of mutual independence (of all 3 variables)\r\n  )\r\n  \r\n  # if test of mutual independence above gives a significant result, \r\n  # further testing is required to ascertain if an association exists between two or all three variables \r\n  # hence hypotheses of partial independence is of interest\r\n  \r\n  # if true, the partial independence hypothesis implies the truth of additional composite hypothesis\r\n  # e.g. for hypothesis P_ijk = P_i.. * P_.jk: if true, P_ij. = P_i.. * P_.j. && P_i.k = P_i.. * P_..k\r\n  \r\n  if (partial == 1 && pval < 0.05) {\r\n    for (i in 1:nrow(array)) {\r\n      for (j in 1:ncol(array)) {\r\n        for (k in 1:nrow(aperm(array))) {\r\n          Ei[i, j, k] <- n_i[i] * n_jk[j,k] / N\r\n          Ej[i, j, k] <- n_j[j] * n_ik[i,k] / N\r\n          Ek[i, j, k] <- n_k[k] * n_ij[i,j] / N\r\n        }\r\n      }\r\n    }\r\n    \r\n    # degrees of freedom\r\n    df_ijk = prod(dim(array)) - prod(dim(array)[2:3]) - dim(array)[1] + 1\r\n\r\n    # test hypothesis that i is independent of j and k\r\n    chisq_i <- sum(((array - Ei) ^ 2) / Ei)\r\n    pval_i  <- pchisq(chisq_i, df_ijk, lower.tail = FALSE)\r\n    \r\n    # test hypothesis that j is independent of i and k\r\n    chisq_j <- sum(((array - Ej) ^ 2) / Ej)\r\n    pval_j  <- pchisq(chisq_j, df_ijk, lower.tail = FALSE)\r\n    \r\n    # test hypothesis that k is independent of i and j\r\n    chisq_k <- sum(((array - Ek) ^ 2) / Ek)\r\n    pval_k  <- pchisq(chisq_k, df_ijk, lower.tail = FALSE)\r\n    \r\n    output <- list(\r\n      test     = \"3 variable contingency table\",\r\n      chisq    = chisq,\r\n      pvalue   = pval,\r\n      df       = df,\r\n      E        = E,\r\n      Ei       = Ei,  # expected values under hypothesis that i is independent of j and k\r\n      Ej       = Ej,  # expected values under hypothesis that j is independent of i and k\r\n      Ek       = Ek,  # expected values under hypothesis that k is independent of i and j\r\n      df_ijk   = df_ijk,  # degrees of freedom for partial independence hypothesis\r\n      chisq_i  = chisq_i,\r\n      chisq_j  = chisq_j,\r\n      chisq_k  = chisq_k,\r\n      pval_i   = pval_i,\r\n      pval_j   = pval_j,\r\n      pval_k   = pval_k\r\n    )\r\n  }\r\n  \r\n  return(output)\r\n}\r\n\r\n\r\n\r\nNested loops might not be the most efficient way to go about it but this is a pretty simple analysis. I was just happy that I got it to work. Now on to testing the function! I used the example that was shown in the book. It was mostly to double check that my function computed the figures correctly.\r\n\r\n\r\n# test input \r\n# this is the same example shown in the book\r\ns <- array(\r\n  c(16,1,7,1,15,3,34,8,5,1,3,3),\r\n  dim = c(2,2,3),\r\n  dimnames = list(\r\n    c('nondev', 'dev'),\r\n    c('notatrisk', 'atrisk'),\r\n    c('low','med','high')\r\n    )\r\n  )\r\nresult <- three_way_xtab(s, partial = 1)\r\n\r\n# print results (exclude tables of expected value)\r\nresult[names(result) != c('E','Ei','Ej','Ek')]\r\n\r\n\r\n$test\r\n[1] \"3 variable contingency table\"\r\n\r\n$chisq\r\n[1] 17.30382\r\n\r\n$pvalue\r\n[1] 0.01553871\r\n\r\n$df\r\n[1] 7\r\n\r\n$df_ijk\r\n[1] 5\r\n\r\n$chisq_i\r\n[1] 6.191387\r\n\r\n$chisq_j\r\n[1] 12.6446\r\n\r\n$chisq_k\r\n[1] 15.06799\r\n\r\n$pval_i\r\n[1] 0.2880391\r\n\r\n$pval_j\r\n[1] 0.02694692\r\n\r\n$pval_k\r\n[1] 0.01007576\r\n\r\nIt should be noted that only mutual independence (of all 3 variables) and partial independence (of any pair of variables) is considered in this function. The next chapter in the book details second order relationships. In other words, an relationship between two of the variables may differ in degree or direction in different categories of the third. The hypothesis of no second-order association between the variables is relatively straightforward. However, there is additional complexity in obtaining the estimates as they can no longer be found directly as products of various marginal totals as is currently done in testing first order relationships.\r\n\r\n\r\n\r\nEveritt, Brian S. 1992. The Analysis of Contingency Tables. 2nd ed. CRC Press. https://doi.org/10.1201/b15072.\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-02-06T16:54:36+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-09-08-crossjoins/",
    "title": "Crossjoins",
    "description": "Exploring crossjoins to find all possible combinations of elements in a list",
    "author": [
      {
        "name": "Jolene",
        "url": {}
      }
    ],
    "date": "2021-09-08",
    "categories": [],
    "contents": "\r\nSuppose we want to find all combinations of desserts from a list of fruits and a list of dessert types. {data.table} has a crossjoin function that is extremely useful to achieve that. CJ automatically arranges the vectors alphabetically.\r\n\r\n\r\nlibrary(purrr)\r\nlibrary(crossmap)\r\nlibrary(data.table)\r\nlibrary(rbenchmark)\r\nlist <- list(\r\n  fruit <- c('apple','apple', 'orange', 'pear', 'peach'), \r\n  type <- c('cake', 'tart', 'pie'),\r\n  s <- c('s', 'd', 'f')\r\n)\r\n\r\n# CJ(x,y) forms a data.table from the cross product of the vectors \r\nCJ(fruit, type, unique = T)\r\n\r\n\r\n     fruit type\r\n 1:  apple cake\r\n 2:  apple  pie\r\n 3:  apple tart\r\n 4: orange cake\r\n 5: orange  pie\r\n 6: orange tart\r\n 7:  peach cake\r\n 8:  peach  pie\r\n 9:  peach tart\r\n10:   pear cake\r\n11:   pear  pie\r\n12:   pear tart\r\n\r\nSidenote: I found that if I changed all the assignment operators for the list to equals, fruit and type become vectors within the list but do not exist outside the list. In other words, if I try to view fruit, R returns Error: object 'fruit' not found.\r\nSince CJ(x,y) is a data.table, the {data.table} syntax DT[...] can be used.\r\n\r\n\r\ndessert_combi_dt <- CJ(fruit, type)[, dessert := paste(fruit, type)]  \r\ndessert_combi_dt\r\n\r\n\r\n\r\nOr, if you just require a vector of the combinations\r\n\r\n\r\ndessert_combi <- CJ(fruit, type)[,paste(fruit, type)]  \r\ndessert_combi\r\n\r\n\r\n [1] \"apple cake\"  \"apple cake\"  \"apple pie\"   \"apple pie\"  \r\n [5] \"apple tart\"  \"apple tart\"  \"orange cake\" \"orange pie\" \r\n [9] \"orange tart\" \"peach cake\"  \"peach pie\"   \"peach tart\" \r\n[13] \"pear cake\"   \"pear pie\"    \"pear tart\"  \r\n\r\nThis post was inspired by a tip I saw online, using xmap_ functions from {crossmap} üì¶\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-02-05T16:46:43+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-09-04-building-the-blog/",
    "title": "Building the blog",
    "description": "First foray into distill blogs!",
    "author": [
      {
        "name": "Jolene",
        "url": {}
      }
    ],
    "date": "2021-09-04",
    "categories": [
      "distill"
    ],
    "contents": "\r\n\r\nContents\r\nHover links\r\nInline code\r\nInline code in aside blocks\r\nOther useful links\r\nRandom\r\n\r\n\r\nI hope to have a more complete post on the tweaks I made to the default distill template. But since this blog is still very much a work-in-progress, I will add to this post as I customise this blog. I have been digging into the {distill} üì¶ Github repo and might even fork it to change some defaults once I have a better understanding of how it works. With the amount of research I am doing, it probably defeats the purpose of choosing {distill} üì¶ over {blogdown} üì¶ for its simplicity. But at this point, I really don‚Äôt feel like switching. If I can get under the hood and tweak {distill} üì¶ to the way I want, there won‚Äôt be a need to jump to {blogdown} üì¶ or other alternatives.\r\nHover links\r\nI wanted a more obvious visual cue when the cursor is hovering over a link. This only applies to links within the article d-article and in a text paragraph p. Here‚Äôs how it looks.\r\nd-article p a {\r\n    border-bottom: 5px solid #cbf8df; \r\n    text-decoration: none;\r\n    display: inline-block;\r\n    line-height: 0.7em;\r\n}\r\nd-article p a:hover {\r\n    background-color: #cbf8df;\r\n    border-bottom: 3px solid #cbf8df;\r\n    border-top: 2px solid #cbf8df;\r\n    line-height: 1em;\r\n}\r\nInline code\r\nd-article p code {\r\n  font-size: 15px;\r\n  font-family: 'Fira mono';\r\n  color: #000000;\r\n  background-color: #f0f0f0;\r\n  padding: 3px;\r\n}\r\nInline code in aside blocks\r\nI‚Äôm not sure if there‚Äôs a default setting for it already. I just formatted it to be similar to d-article p code but with a smaller font size and reduced padding.\r\nd-article aside code {\r\n  font-size: 11px;\r\n  font-family: 'Fira mono';\r\n  color: #000000;\r\n  background-color: #f0f0f0;\r\n  padding: 2px;\r\n}\r\nOther useful links\r\nIncluding meta-tagging and extra content\r\nSome css theme tips\r\nCreating distill site (theming, navigation)\r\nhttps://ellakaye.rbind.io/posts/2021-05-08-welcome-to-my-distill-website/\r\nhttps://www.shamindras.com/posts/2019-07-31-shrotriya2019distillpt2/\r\nhttps://holtzy.github.io/Pimp-my-rmd/\r\nhttps://towardsdatascience.com/ten-awesome-r-markdown-tricks-56ef6d41098\r\nhttps://www.jhelvy.com/posts/2021-03-25-customizing-distill-with-htmltools-and-css/\r\nRandom\r\nhttps://www.ericekholm.com/posts/2021-01-06-pulling-youtube-transcripts/\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-02-06T16:55:17+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-09-04-the-beginning/",
    "title": "The beginning",
    "description": "Trying to put the phrase \"Done is better than perfect\" to practice",
    "author": [
      {
        "name": "Jolene",
        "url": {}
      }
    ],
    "date": "2021-09-04",
    "categories": [],
    "contents": "\r\nAt this point, this blog has been in the works for close to half a year. I struggled a lot with what to post on this blog and I still don‚Äôt have an answer. Every once in a while, inspiration hits and I draft up a half-baked post but I never actually published any of them. I have loads of incomplete drafts and one-liner ideas stashed in a notes app. I know I just need to take a stab at them. I recently watched the movie Tick, Tick, ‚Ä¶ Boom and the line ‚Äúmaybe try writing about what you know‚Äù seems extremely relevant here. Since I have been working on a couple of small projects, I think I will start from there. There‚Äôs going to be some embarrassingly basic posts here. Some posts will simply be yet another variation of ‚Äúhow I managed to do xyz‚Äù on the internet. Who knows? My perspective might provide some value to a lost and confused soul who found their way here through a right combination of words in the search bar and Google‚Äôs invisible hand.\r\nI wish I could say distill üì¶ is simple and straightforward. Well, it was at the start. I had it set up pretty quickly, then promptly left it to rot for months. When I finally decided to actually launch it and publish posts, I ran into a slew of problems. It‚Äôs definitely more straightforward than blogdown üì¶ though. For now, I‚Äôm still tweaking the css and thinking of a domain name to buy. Sinking some money into this will hopefully motivate me to update this blog regularly.\r\nWhat‚Äôs next?\r\nRandom R tips/guides. Curation of interesting R projects. Data explorations. TidyTuesdays. That‚Äôs a wish list. Realistically, this blog will not have consistent updates. My only hope is that I will keep this running, regardless of the pace.\r\nHere goes nothing!\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-02-06T16:57:08+08:00",
    "input_file": {}
  }
]
